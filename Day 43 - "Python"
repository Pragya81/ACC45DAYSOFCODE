# Operators 
# Arithmetic - +, -, *, /, %
# Assignment - =
# Relational - <, >, <=, >=, ==, !=
# Logical - and, or , not
# Unary - 
# Bitwise operator - Complement or tilde(~), And(&), Or(|), XOR(^), Leftshift(<<), Rightshift(>>)

a, b = 5, 6      #Assigning multiple values at the same time
print (a)
print (b)
print(end = '\n')

# Unary operator
n = 10
print(-n)
print(end = '\n')

# Relational
print (a < b)
print (b < a)
print (a == b)
print (a >=b)
print (b <= a)
print (a != b)
print(end = '\n')

# Logical operator
x = 5
y = 4
print(a < 8 and b > 7)
print(a < 8 or b > 7)
x = True
print(not x)

# Bitwise operator
print(~12)
print(~1)
print(~0)

# Binary digit for 13 = 00001101
#1's complement of 13 = 11110010
#2's complement of 13 = 11110010 + 1 = 11110011
# Only positive numbers are stored in the system and negative numbers  are first converted into positive numbers and then they are saved as 1's complement
# Bitwise OR(|)
print(12 | 13) # 12 = 00001101, 13 = 00001101
# Bitwise AND(&)
print(12 & 13)
# Bitwise XOR(^) - 0 0 = 0, 0 1 = 1, 1 1 = 1, 1 1 = 0
print(12 ^ 13) 
# 12 = 00001100
# 13 = 00001101
#Add = 00000001 so answer of 12 ^ 13 is 1

# Leftshift - gaining bits
print(10 << 2) # 10 = 1010, after shfting = 101000 which is 40
# Rightshift - losing buts
print(10 >> 2) # 10 = 1010, After shifting - 10 which is 2

# %%
# Octal(0 - 7) and Hexadecimal(0 9, a -f)
print(bin(25)) # "0b" in output represents binary
0b01010
print(0b01010)
print(oct(25))
print(hex(25))
print(hex(10))
print(0xf)

# Reasoning
a,b = 15,12
x = (a // 4 + b ** 3) < 2000 and (b % 4 != 0)
print(x)
